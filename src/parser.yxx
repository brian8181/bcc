/* Parser for calc++.   -*- C++ -*-

   Copyright (C) 2005-2015, 2018-2021 Free Software Foundation, Inc.

   This file is part of Bison, the GNU Compiler Compiler.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */


%skeleton "lalr1.cc" // -*- C++ -*-
%require "3.8.2"
%language "c++"
%header

%define api.token.raw

%define api.token.constructor
%define api.value.type variant
%define parse.assert

%code requires
{
    #include <string>
    class driver;
}

// The parsing context.
%param { driver& drv }

%locations

%define parse.trace
%define parse.error detailed
%define parse.lac full

%code
{
    #include "/home/brian/src/parser_testing/BUILT_CPP_POC/poc/src/driver.hpp"
}

%define api.token.prefix {TOK_}
%token
  ASSIGN  ":="
  MINUS   "-"
  PLUS    "+"
  STAR    "*"
  SLASH   "/"
  LPAREN  "("
  RPAREN  ")"
;

%token <std::string> IDENTIFIER "identifier"
%token <int> NUMBER "number"
%type <int> exp

%left "+" "-";
%left "*" "/";

%%

%start unit;
unit:   assignments exp          { drv.result = $2; }
        ;

assignments:
        %empty                   {}
        | assignments assignment {}
        ;

assignment:
        "identifier" ":=" exp    { drv.variables[$1] = $3; }
        ;
exp:
        "number"
        | "identifier"           { $$ = drv.variables[$1]; }
        | exp "+" exp            { $$ = $1 + $3; }
        | exp "-" exp            { $$ = $1 - $3; }
        | exp "*" exp            { $$ = $1 * $3; }
        | exp "/" exp            { $$ = $1 / $3; }
        | "(" exp ")"            { $$ = $2; }
        ;
%%

void yy::parser::error(const location_type& l, const std::string& m)
{
    std::cerr << l << ": " << m << '\n';
}

void  yy::parser::report_syntax_error (const context& ctx)
{
        int res = 0;
        std::cerr << ctx.location () << ": syntax error";
        {
                // Report the tokens expected at this point.
                enum { TOKENMAX = 5 };
                symbol_kind_type expected[TOKENMAX];
                nt n = ctx.expected_tokens (ctx, expected, TOKENMAX);
                for (int i = 0; i < n; ++i)
                {
                        std::cerr << i == 0 ? ": expected " : " or " << symbol_name (expected[i]);
                }
        }
        // Report the unexpected token.
        symbol_kind_type lookahead = ctx.token ();
        if (lookahead != symbol_kind::S_YYEMPTY)
        {
                std::cerr << " before " << symbol_name (lookahead));
        }
        std::cerr << '\n';
}

namespace yy
{
        // Report an error to the user.
        auto parser::error (const std::string& msg) -> void
        {
                std::cerr << msg << '\n';
        }
}

int main ()
{
        yy::parser parse;
        return parse;
}
